use super::models::{Vulnerability, VulnerabilityLevel, VulnerabilityReport, ServiceVulnerability};
use crate::error::{Error, Result};
use crate::scanner::ScanResult;
use std::collections::HashMap;
use std::net::IpAddr;
use tracing::{info, debug, warn};

pub struct VulnerabilityDetector {
    database: super::database::VulnerabilityDatabase,
    checks: Vec<Box<dyn VulnerabilityCheck>>,
}

impl VulnerabilityDetector {
    pub fn new() -> Result<Self> {
        let database = super::database::VulnerabilityDatabase::new()?;
        let checks = Self::initialize_checks();
        
        Ok(Self {
            database,
            checks,
        })
    }

    pub async fn analyze_scan(&self, scan_result: &ScanResult) -> Result<VulnerabilityReport> {
        info!("Starting vulnerability analysis for scan: {}", scan_result.id);
        
        let mut report = VulnerabilityReport::new(
            scan_result.id.clone(),
            scan_result.target.clone(),
            scan_result.target_ip,
        );

        // Analyze each open port for vulnerabilities
        for port_info in &scan_result.open_ports {
            let service_vulns = self.analyze_service(
                scan_result.target_ip,
                port_info.port,
                &port_info.service,
                port_info.banner.as_deref(),
            ).await?;

            for vulnerability in service_vulns {
                report.add_vulnerability(vulnerability);
            }
        }

        // Run general security checks
        self.run_general_checks(&scan_result, &mut report).await?;

        info!(
            "Vulnerability analysis completed: {} vulnerabilities found",
            report.vulnerabilities.len()
        );

        Ok(report)
    }

    async fn analyze_service(
        &self,
        target: IpAddr,
        port: u16,
        service: &Option<crate::scanner::ServiceInfo>,
        banner: Option<&str>,
    ) -> Result<Vec<Vulnerability>> {
        let mut vulnerabilities = Vec::new();

        let service_name = service.as_ref()
            .map(|s| s.name.as_str())
            .unwrap_or("unknown");

        let service_version = service.as_ref()
            .and_then(|s| s.version.as_deref());

        // Check database for known vulnerabilities
        if let Some(db_vulns) = self.database.check_service(service_name, service_version).await? {
            for db_vuln in db_vulns {
                vulnerabilities.push(self.convert_db_vulnerability(db_vuln, port, service_name));
            }
        }

        // Run specific vulnerability checks
        for check in &self.checks {
            if check.applies_to(service_name, port) {
                if let Some(vuln) = check.check(target, port, banner).await? {
                    vulnerabilities.push(vuln);
                }
            }
        }

        Ok(vulnerabilities)
    }

    async fn run_general_checks(
        &self,
        scan_result: &ScanResult,
        report: &mut VulnerabilityReport,
    ) -> Result<()> {
        // Check for common misconfigurations
        self.check_common_misconfigurations(scan_result, report).await?;
        
        // Check for information disclosure
        self.check_information_disclosure(scan_result, report).await?;
        
        // Check for weak configurations
        self.check_weak_configurations(scan_result, report).await?;

        Ok(())
    }

    async fn check_common_misconfigurations(
        &self,
        scan_result: &ScanResult,
        report: &mut VulnerabilityReport,
    ) -> Result<()> {
        for port_info in &scan_result.open_ports {
            match port_info.port {
                // FTP anonymous access
                21 => {
                    let vuln = Vulnerability::new(
                        "FTP Anonymous Access Enabled".to_string(),
                        "FTP server allows anonymous access without authentication".to_string(),
                        VulnerabilityLevel::Medium,
                        port_info.port,
                        "FTP".to_string(),
                        "Anonymous FTP access detected".to_string(),
                    );
                    report.add_vulnerability(vuln);
                }
                // Telnet cleartext protocol
                23 => {
                    let vuln = Vulnerability::new(
                        "Telnet Service Exposed".to_string(),
                        "Telnet transmits credentials in cleartext and is considered insecure".to_string(),
                        VulnerabilityLevel::High,
                        port_info.port,
                        "Telnet".to_string(),
                        "Telnet service detected".to_string(),
                    );
                    report.add_vulnerability(vuln);
                }
                // HTTP without HTTPS redirect
                80 => {
                    if !scan_result.open_ports.iter().any(|p| p.port == 443) {
                        let vuln = Vulnerability::new(
                            "HTTP Without HTTPS".to_string(),
                            "HTTP service exposed without HTTPS alternative".to_string(),
                            VulnerabilityLevel::Medium,
                            port_info.port,
                            "HTTP".to_string(),
                            "No HTTPS service detected".to_string(),
                        );
                        report.add_vulnerability(vuln);
                    }
                }
                // Redis without authentication
                6379 => {
                    let vuln = Vulnerability::new(
                        "Redis Without Authentication".to_string(),
                        "Redis database exposed without authentication".to_string(),
                        VulnerabilityLevel::High,
                        port_info.port,
                        "Redis".to_string(),
                        "Redis service detected - check authentication".to_string(),
                    );
                    report.add_vulnerability(vuln);
                }
                _ => {}
            }
        }
        Ok(())
    }

    async fn check_information_disclosure(
        &self,
        scan_result: &ScanResult,
        report: &mut VulnerabilityReport,
    ) -> Result<()> {
        for port_info in &scan_result.open_ports {
            if let Some(banner) = &port_info.banner {
                // Check for version disclosure in banners
                if banner.contains("Version") || banner.contains("version") {
                    let vuln = Vulnerability::new(
                        "Version Information Disclosure".to_string(),
                        "Service banner discloses version information".to_string(),
                        VulnerabilityLevel::Low,
                        port_info.port,
                        port_info.service.as_ref().map(|s| s.name.clone()).unwrap_or("unknown".to_string()),
                        format!("Banner: {}", banner),
                    );
                    report.add_vulnerability(vuln);
                }
            }
        }
        Ok(())
    }

    async fn check_weak_configurations(
        &self,
        scan_result: &ScanResult,
        report: &mut VulnerabilityReport,
    ) -> Result<()> {
        // Check for default credentials (would require actual testing)
        // Check for outdated protocols
        // etc.
        Ok(())
    }

    fn convert_db_vulnerability(
        &self,
        db_vuln: super::models::CveRecord,
        port: u16,
        service: &str,
    ) -> Vulnerability {
        Vulnerability {
            id: uuid::Uuid::new_v4().to_string(),
            cve_id: Some(db_vuln.id),
            title: format!("{} Vulnerability", service),
            description: db_vuln.description,
            level: db_vuln.severity,
            cvss_score: Some(db_vuln.cvss_score),
            cvss_vector: Some(db_vuln.cvss_vector),
            port,
            service: service.to_string(),
            protocol: "TCP".to_string(),
            evidence: "CVE database match".to_string(),
            references: db_vuln.references,
            discovered_at: chrono::Utc::now(),
            mitigation: "Apply security updates".to_string(),
            exploit_available: db_vuln.exploitability.score > 0.0,
            exploit_maturity: Some(super::models::ExploitMaturity::NotDefined),
            impact: "See CVE description".to_string(),
            certainty: 90, // High confidence for CVE matches
            tags: vec!["cve".to_string(), "database".to_string()],
        }
    }

    fn initialize_checks() -> Vec<Box<dyn VulnerabilityCheck>> {
        vec![
            Box::new(SshVulnerabilityCheck::new()),
            Box::new(WebVulnerabilityCheck::new()),
            Box::new(DatabaseVulnerabilityCheck::new()),
            Box::new(SmbVulnerabilityCheck::new()),
            Box::new(RdpVulnerabilityCheck::new()),
        ]
    }
}

// Vulnerability Check Trait
#[async_trait::async_trait]
pub trait VulnerabilityCheck: Send + Sync {
    fn applies_to(&self, service: &str, port: u16) -> bool;
    async fn check(&self, target: IpAddr, port: u16, banner: Option<&str>) -> Result<Option<Vulnerability>>;
}

// SSH Vulnerability Check
struct SshVulnerabilityCheck;

impl SshVulnerabilityCheck {
    fn new() -> Self {
        Self
    }
}

#[async_trait::async_trait]
impl VulnerabilityCheck for SshVulnerabilityCheck {
    fn applies_to(&self, service: &str, port: u16) -> bool {
        service == "ssh" || port == 22
    }

    async fn check(&self, target: IpAddr, port: u16, banner: Option<&str>) -> Result<Option<Vulnerability>> {
        if let Some(banner) = banner {
            // Check for outdated SSH versions
            if banner.contains("OpenSSH") && banner.contains("7.") {
                return Ok(Some(Vulnerability::new(
                    "Potential Outdated SSH Version".to_string(),
                    "SSH version may be outdated and contain known vulnerabilities".to_string(),
                    VulnerabilityLevel::Medium,
                    port,
                    "SSH".to_string(),
                    format!("Banner: {}", banner),
                )));
            }
        }

        Ok(None)
    }
}

// Web Vulnerability Check
struct WebVulnerabilityCheck;

impl WebVulnerabilityCheck {
    fn new() -> Self {
        Self
    }
}

#[async_trait::async_trait]
impl VulnerabilityCheck for WebVulnerabilityCheck {
    fn applies_to(&self, service: &str, port: u16) -> bool {
        service == "http" || service == "https" || port == 80 || port == 443 || port == 8080 || port == 8443
    }

    async fn check(&self, target: IpAddr, port: u16, banner: Option<&str>) -> Result<Option<Vulnerability>> {
        // Check for common web server vulnerabilities
        if let Some(banner) = banner {
            if banner.contains("Apache") && banner.contains("2.4.") {
                return Ok(Some(Vulnerability::new(
                    "Apache Web Server - Check for Updates".to_string(),
                    "Apache version may have known vulnerabilities".to_string(),
                    VulnerabilityLevel::Medium,
                    port,
                    "HTTP".to_string(),
                    format!("Banner: {}", banner),
                )));
            }

            if banner.contains("nginx") {
                return Ok(Some(Vulnerability::new(
                    "nginx Web Server - Check for Updates".to_string(),
                    "nginx version may have known vulnerabilities".to_string(),
                    VulnerabilityLevel::Medium,
                    port,
                    "HTTP".to_string(),
                    format!("Banner: {}", banner),
                )));
            }
        }

        Ok(None)
    }
}

// Database Vulnerability Check
struct DatabaseVulnerabilityCheck;

impl DatabaseVulnerabilityCheck {
    fn new() -> Self {
        Self
    }
}

#[async_trait::async_trait]
impl VulnerabilityCheck for DatabaseVulnerabilityCheck {
    fn applies_to(&self, service: &str, port: u16) -> bool {
        matches!(service, "mysql" | "postgresql" | "mongodb" | "redis") ||
        matches!(port, 3306 | 5432 | 27017 | 6379)
    }

    async fn check(&self, target: IpAddr, port: u16, banner: Option<&str>) -> Result<Option<Vulnerability>> {
        // Database-specific checks would go here
        // For now, return a generic database warning
        Ok(Some(Vulnerability::new(
            "Database Service Exposed to Network".to_string(),
            "Database service should not be directly exposed to the network".to_string(),
            VulnerabilityLevel::High,
            port,
            "Database".to_string(),
            "Network-accessible database detected".to_string(),
        )))
    }
}

// SMB Vulnerability Check
struct SmbVulnerabilityCheck;

impl SmbVulnerabilityCheck {
    fn new() -> Self {
        Self
    }
}

#[async_trait::async_trait]
impl VulnerabilityCheck for SmbVulnerabilityCheck {
    fn applies_to(&self, service: &str, port: u16) -> bool {
        service == "microsoft-ds" || port == 445
    }

    async fn check(&self, target: IpAddr, port: u16, _banner: Option<&str>) -> Result<Option<Vulnerability>> {
        Ok(Some(Vulnerability::new(
            "SMB Service Exposed".to_string(),
            "SMB service exposed - check for EternalBlue and other SMB vulnerabilities".to_string(),
            VulnerabilityLevel::High,
            port,
            "SMB".to_string(),
            "SMB service detected on network".to_string(),
        )))
    }
}

// RDP Vulnerability Check
struct RdpVulnerabilityCheck;

impl RdpVulnerabilityCheck {
    fn new() -> Self {
        Self
    }
}

#[async_trait::async_trait]
impl VulnerabilityCheck for RdpVulnerabilityCheck {
    fn applies_to(&self, service: &str, port: u16) -> bool {
        service == "ms-wbt-server" || port == 3389
    }

    async fn check(&self, target: IpAddr, port: u16, _banner: Option<&str>) -> Result<Option<Vulnerability>> {
        Ok(Some(Vulnerability::new(
            "RDP Service Exposed".to_string(),
            "RDP service exposed - check for BlueKeep and other RDP vulnerabilities".to_string(),
            VulnerabilityLevel::High,
            port,
            "RDP".to_string(),
            "RDP service detected on network".to_string(),
        )))
    }
          }

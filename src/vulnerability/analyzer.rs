use super::models::{VulnerabilityReport, Vulnerability, VulnerabilityLevel};
use crate::error::Result;
use crate::scanner::ScanResult;
use std::collections::HashMap;

pub struct VulnerabilityAnalyzer {
    detector: super::VulnerabilityDetector,
}

impl VulnerabilityAnalyzer {
    pub fn new() -> Result<Self> {
        let detector = super::VulnerabilityDetector::new()?;
        Ok(Self { detector })
    }

    pub async fn analyze_scan(&self, scan_result: &ScanResult) -> Result<VulnerabilityReport> {
        self.detector.analyze_scan(scan_result).await
    }

    pub async fn analyze_multiple_scans(&self, scan_results: &[ScanResult]) -> Result<Vec<VulnerabilityReport>> {
        let mut reports = Vec::new();
        
        for scan_result in scan_results {
            let report = self.analyze_scan(scan_result).await?;
            reports.push(report);
        }
        
        Ok(reports)
    }

    pub fn generate_comparison_report(&self, reports: &[VulnerabilityReport]) -> ComparisonReport {
        let mut comparison = ComparisonReport::new();
        
        for report in reports {
            comparison.add_report(report);
        }
        
        comparison
    }

    pub fn filter_vulnerabilities_by_level(
        &self,
        report: &VulnerabilityReport,
        level: VulnerabilityLevel,
    ) -> Vec<&Vulnerability> {
        report.vulnerabilities
            .iter()
            .filter(|v| v.level == level)
            .collect()
    }

    pub fn get_vulnerability_trends(&self, reports: &[VulnerabilityReport]) -> VulnerabilityTrends {
        let mut trends = VulnerabilityTrends::new();
        
        for report in reports {
            trends.add_data_point(report);
        }
        
        trends
    }
}

#[derive(Debug, Clone)]
pub struct ComparisonReport {
    pub reports: Vec<VulnerabilityReport>,
    pub summary: ComparisonSummary,
}

#[derive(Debug, Clone)]
pub struct ComparisonSummary {
    pub total_reports: usize,
    pub average_risk_score: f32,
    pub most_vulnerable_target: Option<String>,
    pub common_vulnerabilities: Vec<CommonVulnerability>,
}

#[derive(Debug, Clone)]
pub struct CommonVulnerability {
    pub title: String,
    pub count: usize,
    pub average_cvss: f32,
}

#[derive(Debug, Clone)]
pub struct VulnerabilityTrends {
    pub data_points: Vec<TrendDataPoint>,
    pub overall_trend: TrendDirection,
}

#[derive(Debug, Clone)]
pub struct TrendDataPoint {
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub risk_score: f32,
    pub critical_count: usize,
    pub high_count: usize,
}

#[derive(Debug, Clone, PartialEq)]
pub enum TrendDirection {
    Improving,
    Worsening,
    Stable,
}

impl ComparisonReport {
    pub fn new() -> Self {
        Self {
            reports: Vec::new(),
            summary: ComparisonSummary {
                total_reports: 0,
                average_risk_score: 0.0,
                most_vulnerable_target: None,
                common_vulnerabilities: Vec::new(),
            },
        }
    }

    pub fn add_report(&mut self, report: &VulnerabilityReport) {
        self.reports.push(report.clone());
        self.update_summary();
    }

    fn update_summary(&mut self) {
        if self.reports.is_empty() {
            return;
        }

        let total_risk_score: f32 = self.reports.iter()
            .map(|r| r.summary.risk_score)
            .sum();
        self.summary.average_risk_score = total_risk_score / self.reports.len() as f32;

        self.summary.total_reports = self.reports.len();

        // Find most vulnerable target
        self.summary.most_vulnerable_target = self.reports.iter()
            .max_by_key(|r| r.summary.critical_count + r.summary.high_count)
            .map(|r| r.target.clone());

        // Find common vulnerabilities
        self.summary.common_vulnerabilities = self.find_common_vulnerabilities();
    }

    fn find_common_vulnerabilities(&self) -> Vec<CommonVulnerability> {
        let mut vulnerability_counts: HashMap<String, (usize, f32)> = HashMap::new();

        for report in &self.reports {
            for vuln in &report.vulnerabilities {
                let entry = vulnerability_counts
                    .entry(vuln.title.clone())
                    .or_insert((0, 0.0));
                entry.0 += 1;
                entry.1 += vuln.cvss_score.unwrap_or(0.0);
            }
        }

        let mut common: Vec<CommonVulnerability> = vulnerability_counts
            .into_iter()
            .map(|(title, (count, total_cvss))| CommonVulnerability {
                title,
                count,
                average_cvss: total_cvss / count as f32,
            })
            .collect();

        common.sort_by(|a, b| b.count.cmp(&a.count));
        common.truncate(10); // Top 10 most common

        common
    }
}

impl VulnerabilityTrends {
    pub fn new() -> Self {
        Self {
            data_points: Vec::new(),
            overall_trend: TrendDirection::Stable,
        }
    }

    pub fn add_data_point(&mut self, report: &VulnerabilityReport) {
        let data_point = TrendDataPoint {
            timestamp: report.generated_at,
            risk_score: report.summary.risk_score,
            critical_count: report.summary.critical_count,
            high_count: report.summary.high_count,
        };

        self.data_points.push(data_point);
        self.calculate_overall_trend();
    }

    fn calculate_overall_trend(&mut self) {
        if self.data_points.len() < 2 {
            self.overall_trend = TrendDirection::Stable;
            return;
        }

        let first = &self.data_points[0];
        let last = &self.data_points[self.data_points.len() - 1];

        if last.risk_score > first.risk_score + 0.1 {
            self.overall_trend = TrendDirection::Worsening;
        } else if last.risk_score < first.risk_score - 0.1 {
            self.overall_trend = TrendDirection::Improving;
        } else {
            self.overall_trend = TrendDirection::Stable;
        }
    }
}

impl Default for ComparisonReport {
    fn default() -> Self {
        Self::new()
    }
}

impl Default for VulnerabilityTrends {
    fn default() -> Self {
        Self::new()
    }
  }

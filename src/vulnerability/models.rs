use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::net::IpAddr;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityReport {
    pub id: String,
    pub scan_id: String,
    pub target: String,
    pub target_ip: IpAddr,
    pub generated_at: DateTime<Utc>,
    pub vulnerabilities: Vec<Vulnerability>,
    pub summary: VulnerabilitySummary,
    pub risk_assessment: RiskAssessment,
    pub recommendations: Vec<Recommendation>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub cve_id: Option<String>,
    pub title: String,
    pub description: String,
    pub level: VulnerabilityLevel,
    pub cvss_score: Option<f32>,
    pub cvss_vector: Option<String>,
    pub port: u16,
    pub service: String,
    pub protocol: String,
    pub evidence: String,
    pub references: Vec<String>,
    pub discovered_at: DateTime<Utc>,
    pub mitigation: String,
    pub exploit_available: bool,
    pub exploit_maturity: Option<ExploitMaturity>,
    pub impact: String,
    pub certainty: u8, // 0-100%
    pub tags: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum VulnerabilityLevel {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExploitMaturity {
    Unproven,
    ProofOfConcept,
    Functional,
    High,
    NotDefined,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilitySummary {
    pub total_vulnerabilities: usize,
    pub critical_count: usize,
    pub high_count: usize,
    pub medium_count: usize,
    pub low_count: usize,
    pub info_count: usize,
    pub risk_score: f32,
    pub average_cvss: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskAssessment {
    pub overall_risk: VulnerabilityLevel,
    pub business_impact: String,
    pub technical_impact: String,
    pub remediation_effort: RemediationEffort,
    pub urgency: UrgencyLevel,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Recommendation {
    pub id: String,
    pub title: String,
    pub description: String,
    pub priority: RecommendationPriority,
    pub steps: Vec<String>,
    pub estimated_effort: String,
    pub references: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RemediationEffort {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UrgencyLevel {
    Low,
    Medium,
    High,
    Immediate,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RecommendationPriority {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceVulnerability {
    pub service_name: String,
    pub service_version: Option<String>,
    pub port: u16,
    pub protocol: String,
    pub vulnerabilities: Vec<Vulnerability>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CveRecord {
    pub id: String,
    pub description: String,
    pub cvss_score: f32,
    pub cvss_vector: String,
    pub severity: VulnerabilityLevel,
    pub affected_versions: Vec<String>,
    pub references: Vec<String>,
    pub published_date: DateTime<Utc>,
    pub last_modified: DateTime<Utc>,
    pub exploitability: Exploitability,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Exploitability {
    pub score: f32,
    pub vector: String,
    pub attack_vector: AttackVector,
    pub attack_complexity: AttackComplexity,
    pub privileges_required: PrivilegesRequired,
    pub user_interaction: UserInteraction,
    pub scope: Scope,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AttackVector {
    Network,
    Adjacent,
    Local,
    Physical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AttackComplexity {
    Low,
    High,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PrivilegesRequired {
    None,
    Low,
    High,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UserInteraction {
    None,
    Required,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Scope {
    Unchanged,
    Changed,
}

impl VulnerabilityReport {
    pub fn new(scan_id: String, target: String, target_ip: IpAddr) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            scan_id,
            target,
            target_ip,
            generated_at: Utc::now(),
            vulnerabilities: Vec::new(),
            summary: VulnerabilitySummary::default(),
            risk_assessment: RiskAssessment::default(),
            recommendations: Vec::new(),
        }
    }

    pub fn add_vulnerability(&mut self, vulnerability: Vulnerability) {
        self.vulnerabilities.push(vulnerability);
        self.update_summary();
        self.update_risk_assessment();
        self.generate_recommendations();
    }

    pub fn calculate_risk_score(&self) -> f32 {
        let weighted_sum: f32 = self.vulnerabilities.iter()
            .map(|v| {
                let weight = match v.level {
                    VulnerabilityLevel::Critical => 10.0,
                    VulnerabilityLevel::High => 7.5,
                    VulnerabilityLevel::Medium => 5.0,
                    VulnerabilityLevel::Low => 2.5,
                    VulnerabilityLevel::Info => 1.0,
                };
                weight * (v.certainty as f32 / 100.0)
            })
            .sum();

        weighted_sum / self.vulnerabilities.len().max(1) as f32
    }

    fn update_summary(&mut self) {
        let critical_count = self.vulnerabilities.iter()
            .filter(|v| v.level == VulnerabilityLevel::Critical)
            .count();
        let high_count = self.vulnerabilities.iter()
            .filter(|v| v.level == VulnerabilityLevel::High)
            .count();
        let medium_count = self.vulnerabilities.iter()
            .filter(|v| v.level == VulnerabilityLevel::Medium)
            .count();
        let low_count = self.vulnerabilities.iter()
            .filter(|v| v.level == VulnerabilityLevel::Low)
            .count();
        let info_count = self.vulnerabilities.iter()
            .filter(|v| v.level == VulnerabilityLevel::Info)
            .count();

        let total_cvss: f32 = self.vulnerabilities.iter()
            .filter_map(|v| v.cvss_score)
            .sum();
        let cvss_count = self.vulnerabilities.iter()
            .filter(|v| v.cvss_score.is_some())
            .count();

        let average_cvss = if cvss_count > 0 {
            total_cvss / cvss_count as f32
        } else {
            0.0
        };

        self.summary = VulnerabilitySummary {
            total_vulnerabilities: self.vulnerabilities.len(),
            critical_count,
            high_count,
            medium_count,
            low_count,
            info_count,
            risk_score: self.calculate_risk_score(),
            average_cvss,
        };
    }

    fn update_risk_assessment(&mut self) {
        let overall_risk = if self.summary.critical_count > 0 {
            VulnerabilityLevel::Critical
        } else if self.summary.high_count > 0 {
            VulnerabilityLevel::High
        } else if self.summary.medium_count > 0 {
            VulnerabilityLevel::Medium
        } else if self.summary.low_count > 0 {
            VulnerabilityLevel::Low
        } else {
            VulnerabilityLevel::Info
        };

        self.risk_assessment = RiskAssessment {
            overall_risk,
            business_impact: self.assess_business_impact(),
            technical_impact: self.assess_technical_impact(),
            remediation_effort: self.assess_remediation_effort(),
            urgency: self.assess_urgency(),
        };
    }

    fn assess_business_impact(&self) -> String {
        if self.summary.critical_count > 0 {
            "Potential complete system compromise, data breach, or service disruption".to_string()
        } else if self.summary.high_count > 0 {
            "Significant data exposure or system control possible".to_string()
        } else if self.summary.medium_count > 0 {
            "Limited data exposure or partial system control possible".to_string()
        } else {
            "Minimal business impact expected".to_string()
        }
    }

    fn assess_technical_impact(&self) -> String {
        if self.summary.critical_count > 0 {
            "Remote code execution, complete system takeover".to_string()
        } else if self.summary.high_count > 0 {
            "Privilege escalation, sensitive data access".to_string()
        } else if self.summary.medium_count > 0 {
            "Information disclosure, limited system access".to_string()
        } else {
            "Configuration issues, information leakage".to_string()
        }
    }

    fn assess_remediation_effort(&self) -> RemediationEffort {
        match self.summary.overall_risk() {
            VulnerabilityLevel::Critical => RemediationEffort::Critical,
            VulnerabilityLevel::High => RemediationEffort::High,
            VulnerabilityLevel::Medium => RemediationEffort::Medium,
            _ => RemediationEffort::Low,
        }
    }

    fn assess_urgency(&self) -> UrgencyLevel {
        match self.summary.overall_risk() {
            VulnerabilityLevel::Critical => UrgencyLevel::Immediate,
            VulnerabilityLevel::High => UrgencyLevel::High,
            VulnerabilityLevel::Medium => UrgencyLevel::Medium,
            _ => UrgencyLevel::Low,
        }
    }

    fn generate_recommendations(&mut self) {
        self.recommendations.clear();

        // Generate recommendations based on vulnerabilities
        for vuln in &self.vulnerabilities {
            let recommendation = self.create_recommendation_for_vulnerability(vuln);
            self.recommendations.push(recommendation);
        }

        // Sort by priority
        self.recommendations.sort_by(|a, b| {
            b.priority.cmp(&a.priority)
        });
    }

    fn create_recommendation_for_vulnerability(&self, vuln: &Vulnerability) -> Recommendation {
        let (title, steps, effort) = match vuln.service.as_str() {
            "SSH" => (
                "Secure SSH Configuration",
                vec![
                    "Disable SSH protocol version 1".to_string(),
                    "Use key-based authentication".to_string(),
                    "Configure fail2ban for brute force protection".to_string(),
                    "Change default SSH port".to_string(),
                ],
                "Low".to_string(),
            ),
            "HTTP" | "HTTPS" => (
                "Harden Web Server",
                vec![
                    "Update to latest version".to_string(),
                    "Configure security headers".to_string(),
                    "Disable unnecessary HTTP methods".to_string(),
                    "Implement WAF".to_string(),
                ],
                "Medium".to_string(),
            ),
            _ => (
                "General Security Hardening",
                vec![
                    "Update service to latest version".to_string(),
                    "Review and restrict network access".to_string(),
                    "Implement proper authentication".to_string(),
                    "Monitor for suspicious activity".to_string(),
                ],
                "Medium".to_string(),
            ),
        };

        Recommendation {
            id: uuid::Uuid::new_v4().to_string(),
            title: title.to_string(),
            description: format!("Remediate {} vulnerability on port {}", vuln.service, vuln.port),
            priority: match vuln.level {
                VulnerabilityLevel::Critical => RecommendationPriority::Critical,
                VulnerabilityLevel::High => RecommendationPriority::High,
                VulnerabilityLevel::Medium => RecommendationPriority::Medium,
                _ => RecommendationPriority::Low,
            },
            steps,
            estimated_effort: effort,
            references: vuln.references.clone(),
        }
    }
}

impl VulnerabilitySummary {
    pub fn overall_risk(&self) -> VulnerabilityLevel {
        if self.critical_count > 0 {
            VulnerabilityLevel::Critical
        } else if self.high_count > 0 {
            VulnerabilityLevel::High
        } else if self.medium_count > 0 {
            VulnerabilityLevel::Medium
        } else if self.low_count > 0 {
            VulnerabilityLevel::Low
        } else {
            VulnerabilityLevel::Info
        }
    }
}

impl Default for VulnerabilitySummary {
    fn default() -> Self {
        Self {
            total_vulnerabilities: 0,
            critical_count: 0,
            high_count: 0,
            medium_count: 0,
            low_count: 0,
            info_count: 0,
            risk_score: 0.0,
            average_cvss: 0.0,
        }
    }
}

impl Default for RiskAssessment {
    fn default() -> Self {
        Self {
            overall_risk: VulnerabilityLevel::Info,
            business_impact: "No significant impact identified".to_string(),
            technical_impact: "No technical impact identified".to_string(),
            remediation_effort: RemediationEffort::Low,
            urgency: UrgencyLevel::Low,
        }
    }
}

impl Vulnerability {
    pub fn new(
        title: String,
        description: String,
        level: VulnerabilityLevel,
        port: u16,
        service: String,
        evidence: String,
    ) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            cve_id: None,
            title,
            description,
            level,
            cvss_score: None,
            cvss_vector: None,
            port,
            service,
            protocol: "TCP".to_string(), // Default
            evidence,
            references: Vec::new(),
            discovered_at: Utc::now(),
            mitigation: "Consult security advisory".to_string(),
            exploit_available: false,
            exploit_maturity: None,
            impact: "Varies".to_string(),
            certainty: 80, // Default confidence
            tags: Vec::new(),
        }
    }
          }

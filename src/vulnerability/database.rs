use sqlx::{sqlite::{SqlitePool, SqlitePoolOptions, SqliteRow}, Row, query, query_as};
use crate::error::{Error, Result};
use std::time::Duration;
use tracing::{info, error, debug};

#[derive(Clone)]
pub struct Database {
    pool: SqlitePool,
}

impl Database {
    pub async fn new(connection_string: &str) -> Result<Self> {
        info!("Initializing database connection: {}", connection_string);
        
        let pool = SqlitePoolOptions::new()
            .max_connections(20)
            .acquire_timeout(Duration::from_secs(30))
            .connect(connection_string)
            .await
            .map_err(|e| Error::Database(e))?;

        // Run migrations
        Self::run_migrations(&pool).await?;
        
        info!("Database initialized successfully");
        Ok(Self { pool })
    }

    async fn run_migrations(pool: &SqlitePool) -> Result<()> {
        info!("Running database migrations...");
        
        // Enable WAL mode for better performance
        sqlx::query("PRAGMA journal_mode = WAL;")
            .execute(pool)
            .await?;

        // Enable foreign keys
        sqlx::query("PRAGMA foreign_keys = ON;")
            .execute(pool)
            .await?;

        // Create scans table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS scans (
                id TEXT PRIMARY KEY,
                target TEXT NOT NULL,
                target_ip TEXT NOT NULL,
                scan_type TEXT NOT NULL,
                start_time DATETIME NOT NULL,
                end_time DATETIME NOT NULL,
                total_ports INTEGER NOT NULL,
                open_ports INTEGER NOT NULL,
                scan_duration_ms INTEGER NOT NULL,
                status TEXT NOT NULL CHECK(status IN ('running', 'completed', 'failed', 'cancelled')),
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
            "#
        ).execute(pool).await?;

        // Create ports table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS scan_ports (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT NOT NULL,
                port INTEGER NOT NULL,
                status TEXT NOT NULL CHECK(status IN ('open', 'closed', 'filtered', 'unknown')),
                service_name TEXT,
                service_version TEXT,
                service_product TEXT,
                banner TEXT,
                response_time_ms INTEGER,
                protocol TEXT NOT NULL DEFAULT 'tcp',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (scan_id) REFERENCES scans (id) ON DELETE CASCADE,
                UNIQUE(scan_id, port)
            )
            "#
        ).execute(pool).await?;

        // Create vulnerabilities table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id TEXT PRIMARY KEY,
                scan_id TEXT NOT NULL,
                cve_id TEXT,
                title TEXT NOT NULL,
                description TEXT NOT NULL,
                level TEXT NOT NULL CHECK(level IN ('info', 'low', 'medium', 'high', 'critical')),
                cvss_score REAL,
                cvss_vector TEXT,
                port INTEGER NOT NULL,
                service TEXT NOT NULL,
                protocol TEXT NOT NULL DEFAULT 'tcp',
                evidence TEXT NOT NULL,
                references_json TEXT,
                discovered_at DATETIME NOT NULL,
                mitigation TEXT NOT NULL,
                exploit_available BOOLEAN DEFAULT 0,
                impact TEXT,
                certainty INTEGER DEFAULT 80,
                tags_json TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (scan_id) REFERENCES scans (id) ON DELETE CASCADE
            )
            "#
        ).execute(pool).await?;

        // Create vulnerability_references table for normalized references
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS vulnerability_references (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                vulnerability_id TEXT NOT NULL,
                url TEXT NOT NULL,
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (vulnerability_id) REFERENCES vulnerabilities (id) ON DELETE CASCADE
            )
            "#
        ).execute(pool).await?;

        // Create scan_statistics table for performance metrics
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS scan_statistics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT NOT NULL,
                packets_sent INTEGER DEFAULT 0,
                packets_received INTEGER DEFAULT 0,
                success_rate REAL DEFAULT 0.0,
                average_response_time_ms REAL DEFAULT 0.0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (scan_id) REFERENCES scans (id) ON DELETE CASCADE,
                UNIQUE(scan_id)
            )
            "#
        ).execute(pool).await?;

        // Create scan_metadata table for additional scan information
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS scan_metadata (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT NOT NULL,
                scanner_version TEXT NOT NULL,
                arguments_json TEXT,
                hostname TEXT,
                os_name TEXT,
                os_version TEXT,
                os_accuracy INTEGER,
                traceroute_json TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (scan_id) REFERENCES scans (id) ON DELETE CASCADE,
                UNIQUE(scan_id)
            )
            "#
        ).execute(pool).await?;

        // Create indexes for performance
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_scans_target ON scans(target)").execute(pool).await?;
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_scans_created_at ON scans(created_at)").execute(pool).await?;
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_scan_ports_scan_id ON scan_ports(scan_id)").execute(pool).await?;
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_scan_ports_port ON scan_ports(port)").execute(pool).await?;
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_vulnerabilities_scan_id ON vulnerabilities(scan_id)").execute(pool).await?;
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_vulnerabilities_level ON vulnerabilities(level)").execute(pool).await?;
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_vulnerabilities_port ON vulnerabilities(port)").execute(pool).await?;

        // Create triggers for updated_at
        sqlx::query(
            r#"
            CREATE TRIGGER IF NOT EXISTS update_scans_timestamp 
            AFTER UPDATE ON scans
            FOR EACH ROW
            BEGIN
                UPDATE scans SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
            END
            "#
        ).execute(pool).await?;

        info!("Database migrations completed successfully");
        Ok(())
    }

    pub async fn health_check(&self) -> Result<bool> {
        match sqlx::query("SELECT 1").execute(&self.pool).await {
            Ok(_) => Ok(true),
            Err(e) => {
                error!("Database health check failed: {}", e);
                Err(Error::Database(e))
            }
        }
    }

    pub async fn begin_transaction(&self) -> Result<sqlx::Transaction<'_, sqlx::Sqlite>> {
        self.pool.begin().await.map_err(Error::Database)
    }

    pub async fn backup_database(&self, backup_path: &str) -> Result<()> {
        info!("Creating database backup: {}", backup_path);
        
        // Use SQLite backup API via VACUUM INTO
        let backup_query = format!("VACUUM INTO '{}'", backup_path);
        sqlx::query(&backup_query)
            .execute(&self.pool)
            .await
            .map_err(Error::Database)?;
            
        info!("Database backup created successfully: {}", backup_path);
        Ok(())
    }

    pub async fn optimize_database(&self) -> Result<()> {
        info!("Optimizing database...");
        
        // Run VACUUM to optimize storage
        sqlx::query("VACUUM")
            .execute(&self.pool)
            .await?;
            
        // Run ANALYZE for query optimizer
        sqlx::query("ANALYZE")
            .execute(&self.pool)
            .await?;
            
        info!("Database optimization completed");
        Ok(())
    }

    pub async fn get_database_stats(&self) -> Result<DatabaseStats> {
        let scan_count: (i64,) = sqlx::query_as("SELECT COUNT(*) FROM scans")
            .fetch_one(&self.pool)
            .await?;

        let vulnerability_count: (i64,) = sqlx::query_as("SELECT COUNT(*) FROM vulnerabilities")
            .fetch_one(&self.pool)
            .await?;

        let total_ports_scanned: (i64,) = sqlx::query_as("SELECT SUM(total_ports) FROM scans")
            .fetch_one(&self.pool)
            .await?;

        let database_size: (i64,) = sqlx::query_as(
            "SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()"
        )
        .fetch_one(&self.pool)
        .await?;

        Ok(DatabaseStats {
            total_scans: scan_count.0 as u64,
            total_vulnerabilities: vulnerability_count.0 as u64,
            total_ports_scanned: total_ports_scanned.0.unwrap_or(0) as u64,
            database_size_bytes: database_size.0 as u64,
        })
    }

    // Get raw connection pool for complex operations
    pub fn get_pool(&self) -> &SqlitePool {
        &self.pool
    }
}

#[derive(Debug, Clone)]
pub struct DatabaseStats {
    pub total_scans: u64,
    pub total_vulnerabilities: u64,
    pub total_ports_scanned: u64,
    pub database_size_bytes: u64,
}

// Implementation for connection management
impl Database {
    pub async fn close(&self) -> Result<()> {
        self.pool.close().await;
        info!("Database connection closed");
        Ok(())
    }

    pub async fn acquire_connection(&self) -> Result<sqlx::pool::PoolConnection<sqlx::Sqlite>> {
        self.pool.acquire().await.map_err(Error::Database)
    }
}

// Database configuration
pub struct DatabaseConfig {
    pub connection_string: String,
    pub max_connections: u32,
    pub min_connections: u32,
    pub acquire_timeout_secs: u64,
    pub idle_timeout_secs: u64,
    pub max_lifetime_secs: u64,
}

impl Default for DatabaseConfig {
    fn default() -> Self {
        Self {
            connection_string: "sqlite:portscanner.db".to_string(),
            max_connections: 20,
            min_connections: 5,
            acquire_timeout_secs: 30,
            idle_timeout_secs: 300,
            max_lifetime_secs: 1800,
        }
    }
}

impl DatabaseConfig {
    pub fn with_connection_string(mut self, connection_string: String) -> Self {
        self.connection_string = connection_string;
        self
    }

    pub async fn create_pool(&self) -> Result<SqlitePool> {
        SqlitePoolOptions::new()
            .max_connections(self.max_connections)
            .min_connections(self.min_connections)
            .acquire_timeout(Duration::from_secs(self.acquire_timeout_secs))
            .idle_timeout(Duration::from_secs(self.idle_timeout_secs))
            .max_lifetime(Duration::from_secs(self.max_lifetime_secs))
            .connect(&self.connection_string)
            .await
            .map_err(Error::Database)
    }
}

// Database utilities
pub struct DatabaseUtils;

impl DatabaseUtils {
    pub async fn compact_database(pool: &SqlitePool) -> Result<()> {
        // Run PRAGMA optimizations
        sqlx::query("PRAGMA optimize;").execute(pool).await?;
        sqlx::query("PRAGMA wal_checkpoint(TRUNCATE);").execute(pool).await?;
        Ok(())
    }

    pub async fn get_table_sizes(pool: &SqlitePool) -> Result<Vec<TableSize>> {
        let sizes = sqlx::query_as(
            r#"
            SELECT 
                name as table_name,
                (SELECT COUNT(*) FROM sqlite_master WHERE type = 'table' AND name = m.name) as exists_flag,
                (SELECT COUNT(*) FROM pragma_table_info(m.name)) as column_count,
                (SELECT COUNT(*) FROM m.name) as row_count,
                (SELECT SUM(pgsize) FROM dbstat WHERE name = m.name) as size_bytes
            FROM sqlite_master m
            WHERE m.type = 'table' AND m.name NOT LIKE 'sqlite_%'
            ORDER BY size_bytes DESC
            "#
        )
        .fetch_all(pool)
        .await?;

        Ok(sizes)
    }

    pub async fn export_schema(pool: &SqlitePool) -> Result<String> {
        let tables = sqlx::query(
            "SELECT sql FROM sqlite_master WHERE type = 'table' AND name NOT LIKE 'sqlite_%'"
        )
        .fetch_all(pool)
        .await?;

        let mut schema = String::new();
        for table in tables {
            let sql: String = table.get(0);
            schema.push_str(&sql);
            schema.push_str(";\n\n");
        }

        Ok(schema)
    }
}

#[derive(Debug, sqlx::FromRow)]
pub struct TableSize {
    pub table_name: String,
    pub exists_flag: i64,
    pub column_count: i64,
    pub row_count: i64,
    pub size_bytes: Option<i64>,
}

// Database error handling utilities
pub struct DatabaseErrorHandler;

impl DatabaseErrorHandler {
    pub fn is_connection_error(error: &sqlx::Error) -> bool {
        matches!(error, 
            sqlx::Error::PoolTimedOut | 
            sqlx::Error::PoolClosed | 
            sqlx::Error::Io(_) |
            sqlx::Error::Database(_)
        )
    }

    pub fn is_constraint_violation(error: &sqlx::Error) -> bool {
        if let sqlx::Error::Database(db_err) = error {
            db_err.code().as_deref() == Some("2067") || // SQLITE_CONSTRAINT_UNIQUE
            db_err.code().as_deref() == Some("1555") || // SQLITE_CONSTRAINT_PRIMARYKEY
            db_err.code().as_deref() == Some("1811")    // SQLITE_CONSTRAINT_FOREIGNKEY
        } else {
            false
        }
    }

    pub fn should_retry(error: &sqlx::Error) -> bool {
        matches!(error,
            sqlx::Error::PoolTimedOut |
            sqlx::Error::Io(_) |
            sqlx::Error::Database(_) // Some database errors might be retryable
        )
    }
}
